{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Dispatcher\n * \n * @preventMunge\n */\n\n'use strict';\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nvar invariant = require(\"fbjs/lib/invariant\");\nvar _prefix = 'ID_';\n\n/**\n * Dispatcher is used to broadcast payloads to registered callbacks. This is\n * different from generic pub-sub systems in two ways:\n *\n *   1) Callbacks are not subscribed to particular events. Every payload is\n *      dispatched to every registered callback.\n *   2) Callbacks can be deferred in whole or part until other callbacks have\n *      been executed.\n *\n * For example, consider this hypothetical flight destination form, which\n * selects a default city when a country is selected:\n *\n *   var flightDispatcher = new Dispatcher();\n *\n *   // Keeps track of which country is selected\n *   var CountryStore = {country: null};\n *\n *   // Keeps track of which city is selected\n *   var CityStore = {city: null};\n *\n *   // Keeps track of the base flight price of the selected city\n *   var FlightPriceStore = {price: null}\n *\n * When a user changes the selected city, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'city-update',\n *     selectedCity: 'paris'\n *   });\n *\n * This payload is digested by `CityStore`:\n *\n *   flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'city-update') {\n *       CityStore.city = payload.selectedCity;\n *     }\n *   });\n *\n * When the user selects a country, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'country-update',\n *     selectedCountry: 'australia'\n *   });\n *\n * This payload is digested by both stores:\n *\n *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       CountryStore.country = payload.selectedCountry;\n *     }\n *   });\n *\n * When the callback to update `CountryStore` is registered, we save a reference\n * to the returned token. Using this token with `waitFor()`, we can guarantee\n * that `CountryStore` is updated before the callback that updates `CityStore`\n * needs to query its data.\n *\n *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       // `CountryStore.country` may not be updated.\n *       flightDispatcher.waitFor([CountryStore.dispatchToken]);\n *       // `CountryStore.country` is now guaranteed to be updated.\n *\n *       // Select the default city for the new country\n *       CityStore.city = getDefaultCityForCountry(CountryStore.country);\n *     }\n *   });\n *\n * The usage of `waitFor()` can be chained, for example:\n *\n *   FlightPriceStore.dispatchToken =\n *     flightDispatcher.register(function(payload) {\n *       switch (payload.actionType) {\n *         case 'country-update':\n *         case 'city-update':\n *           flightDispatcher.waitFor([CityStore.dispatchToken]);\n *           FlightPriceStore.price =\n *             getFlightPriceStore(CountryStore.country, CityStore.city);\n *           break;\n *     }\n *   });\n *\n * The `country-update` payload will be guaranteed to invoke the stores'\n * registered callbacks in order: `CountryStore`, `CityStore`, then\n * `FlightPriceStore`.\n */\nvar Dispatcher = /*#__PURE__*/function () {\n  function Dispatcher() {\n    _defineProperty(this, \"_callbacks\", void 0);\n    _defineProperty(this, \"_isDispatching\", void 0);\n    _defineProperty(this, \"_isHandled\", void 0);\n    _defineProperty(this, \"_isPending\", void 0);\n    _defineProperty(this, \"_lastID\", void 0);\n    _defineProperty(this, \"_pendingPayload\", void 0);\n    this._callbacks = {};\n    this._isDispatching = false;\n    this._isHandled = {};\n    this._isPending = {};\n    this._lastID = 1;\n  }\n\n  /**\n   * Registers a callback to be invoked with every dispatched payload. Returns\n   * a token that can be used with `waitFor()`.\n   */\n  var _proto = Dispatcher.prototype;\n  _proto.register = function register(callback) {\n    var id = _prefix + this._lastID++;\n    this._callbacks[id] = callback;\n    return id;\n  }\n\n  /**\n   * Removes a callback based on its token.\n   */;\n  _proto.unregister = function unregister(id) {\n    !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n    delete this._callbacks[id];\n  }\n\n  /**\n   * Waits for the callbacks specified to be invoked before continuing execution\n   * of the current callback. This method should only be used by a callback in\n   * response to a dispatched payload.\n   */;\n  _proto.waitFor = function waitFor(ids) {\n    !this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : void 0;\n    for (var ii = 0; ii < ids.length; ii++) {\n      var id = ids[ii];\n      if (this._isPending[id]) {\n        !this._isHandled[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : void 0;\n        continue;\n      }\n      !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n      this._invokeCallback(id);\n    }\n  }\n\n  /**\n   * Dispatches a payload to all registered callbacks.\n   */;\n  _proto.dispatch = function dispatch(payload) {\n    !!this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : void 0;\n    this._startDispatching(payload);\n    try {\n      for (var id in this._callbacks) {\n        if (this._isPending[id]) {\n          continue;\n        }\n        this._invokeCallback(id);\n      }\n    } finally {\n      this._stopDispatching();\n    }\n  }\n\n  /**\n   * Is this Dispatcher currently dispatching.\n   */;\n  _proto.isDispatching = function isDispatching() {\n    return this._isDispatching;\n  }\n\n  /**\n   * Call the callback stored with the given id. Also do some internal\n   * bookkeeping.\n   *\n   * @internal\n   */;\n  _proto._invokeCallback = function _invokeCallback(id) {\n    this._isPending[id] = true;\n    this._callbacks[id](this._pendingPayload);\n    this._isHandled[id] = true;\n  }\n\n  /**\n   * Set up bookkeeping needed when dispatching.\n   *\n   * @internal\n   */;\n  _proto._startDispatching = function _startDispatching(payload) {\n    for (var id in this._callbacks) {\n      this._isPending[id] = false;\n      this._isHandled[id] = false;\n    }\n    this._pendingPayload = payload;\n    this._isDispatching = true;\n  }\n\n  /**\n   * Clear bookkeeping used for dispatching.\n   *\n   * @internal\n   */;\n  _proto._stopDispatching = function _stopDispatching() {\n    delete this._pendingPayload;\n    this._isDispatching = false;\n  };\n  return Dispatcher;\n}();\nmodule.exports = Dispatcher;","map":{"version":3,"names":["_defineProperty","obj","key","value","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","invariant","require","_prefix","Dispatcher","_callbacks","_isDispatching","_isHandled","_isPending","_lastID","_proto","prototype","register","callback","id","unregister","process","env","NODE_ENV","waitFor","ids","ii","length","_invokeCallback","dispatch","payload","_startDispatching","_stopDispatching","isDispatching","_pendingPayload","module","exports"],"sources":["E:/Documentos/UTrabajo------------/DilbaniHelps/proyecto1_base_consumo_api_hipotetica/flux_base_MasGlobal/node_modules/flux/lib/Dispatcher.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Dispatcher\n * \n * @preventMunge\n */\n\n'use strict';\n\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar invariant = require(\"fbjs/lib/invariant\");\nvar _prefix = 'ID_';\n\n/**\n * Dispatcher is used to broadcast payloads to registered callbacks. This is\n * different from generic pub-sub systems in two ways:\n *\n *   1) Callbacks are not subscribed to particular events. Every payload is\n *      dispatched to every registered callback.\n *   2) Callbacks can be deferred in whole or part until other callbacks have\n *      been executed.\n *\n * For example, consider this hypothetical flight destination form, which\n * selects a default city when a country is selected:\n *\n *   var flightDispatcher = new Dispatcher();\n *\n *   // Keeps track of which country is selected\n *   var CountryStore = {country: null};\n *\n *   // Keeps track of which city is selected\n *   var CityStore = {city: null};\n *\n *   // Keeps track of the base flight price of the selected city\n *   var FlightPriceStore = {price: null}\n *\n * When a user changes the selected city, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'city-update',\n *     selectedCity: 'paris'\n *   });\n *\n * This payload is digested by `CityStore`:\n *\n *   flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'city-update') {\n *       CityStore.city = payload.selectedCity;\n *     }\n *   });\n *\n * When the user selects a country, we dispatch the payload:\n *\n *   flightDispatcher.dispatch({\n *     actionType: 'country-update',\n *     selectedCountry: 'australia'\n *   });\n *\n * This payload is digested by both stores:\n *\n *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       CountryStore.country = payload.selectedCountry;\n *     }\n *   });\n *\n * When the callback to update `CountryStore` is registered, we save a reference\n * to the returned token. Using this token with `waitFor()`, we can guarantee\n * that `CountryStore` is updated before the callback that updates `CityStore`\n * needs to query its data.\n *\n *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {\n *     if (payload.actionType === 'country-update') {\n *       // `CountryStore.country` may not be updated.\n *       flightDispatcher.waitFor([CountryStore.dispatchToken]);\n *       // `CountryStore.country` is now guaranteed to be updated.\n *\n *       // Select the default city for the new country\n *       CityStore.city = getDefaultCityForCountry(CountryStore.country);\n *     }\n *   });\n *\n * The usage of `waitFor()` can be chained, for example:\n *\n *   FlightPriceStore.dispatchToken =\n *     flightDispatcher.register(function(payload) {\n *       switch (payload.actionType) {\n *         case 'country-update':\n *         case 'city-update':\n *           flightDispatcher.waitFor([CityStore.dispatchToken]);\n *           FlightPriceStore.price =\n *             getFlightPriceStore(CountryStore.country, CityStore.city);\n *           break;\n *     }\n *   });\n *\n * The `country-update` payload will be guaranteed to invoke the stores'\n * registered callbacks in order: `CountryStore`, `CityStore`, then\n * `FlightPriceStore`.\n */\nvar Dispatcher = /*#__PURE__*/function () {\n  function Dispatcher() {\n    _defineProperty(this, \"_callbacks\", void 0);\n    _defineProperty(this, \"_isDispatching\", void 0);\n    _defineProperty(this, \"_isHandled\", void 0);\n    _defineProperty(this, \"_isPending\", void 0);\n    _defineProperty(this, \"_lastID\", void 0);\n    _defineProperty(this, \"_pendingPayload\", void 0);\n    this._callbacks = {};\n    this._isDispatching = false;\n    this._isHandled = {};\n    this._isPending = {};\n    this._lastID = 1;\n  }\n\n  /**\n   * Registers a callback to be invoked with every dispatched payload. Returns\n   * a token that can be used with `waitFor()`.\n   */\n  var _proto = Dispatcher.prototype;\n  _proto.register = function register(callback) {\n    var id = _prefix + this._lastID++;\n    this._callbacks[id] = callback;\n    return id;\n  }\n\n  /**\n   * Removes a callback based on its token.\n   */;\n  _proto.unregister = function unregister(id) {\n    !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n    delete this._callbacks[id];\n  }\n\n  /**\n   * Waits for the callbacks specified to be invoked before continuing execution\n   * of the current callback. This method should only be used by a callback in\n   * response to a dispatched payload.\n   */;\n  _proto.waitFor = function waitFor(ids) {\n    !this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : void 0;\n    for (var ii = 0; ii < ids.length; ii++) {\n      var id = ids[ii];\n      if (this._isPending[id]) {\n        !this._isHandled[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : void 0;\n        continue;\n      }\n      !this._callbacks[id] ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : void 0;\n      this._invokeCallback(id);\n    }\n  }\n\n  /**\n   * Dispatches a payload to all registered callbacks.\n   */;\n  _proto.dispatch = function dispatch(payload) {\n    !!this._isDispatching ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : void 0;\n    this._startDispatching(payload);\n    try {\n      for (var id in this._callbacks) {\n        if (this._isPending[id]) {\n          continue;\n        }\n        this._invokeCallback(id);\n      }\n    } finally {\n      this._stopDispatching();\n    }\n  }\n\n  /**\n   * Is this Dispatcher currently dispatching.\n   */;\n  _proto.isDispatching = function isDispatching() {\n    return this._isDispatching;\n  }\n\n  /**\n   * Call the callback stored with the given id. Also do some internal\n   * bookkeeping.\n   *\n   * @internal\n   */;\n  _proto._invokeCallback = function _invokeCallback(id) {\n    this._isPending[id] = true;\n    this._callbacks[id](this._pendingPayload);\n    this._isHandled[id] = true;\n  }\n\n  /**\n   * Set up bookkeeping needed when dispatching.\n   *\n   * @internal\n   */;\n  _proto._startDispatching = function _startDispatching(payload) {\n    for (var id in this._callbacks) {\n      this._isPending[id] = false;\n      this._isHandled[id] = false;\n    }\n    this._pendingPayload = payload;\n    this._isDispatching = true;\n  }\n\n  /**\n   * Clear bookkeeping used for dispatching.\n   *\n   * @internal\n   */;\n  _proto._stopDispatching = function _stopDispatching() {\n    delete this._pendingPayload;\n    this._isDispatching = false;\n  };\n  return Dispatcher;\n}();\nmodule.exports = Dispatcher;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}